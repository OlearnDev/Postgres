----- PostegreSQL -----------

https://www.youtube.com/watch?v=Tn67kCaLElk&list=PLwxrtuGg5dNGv4jvDY3TEddn2HIn4-uF9&index=2

1.Intro and Architecture -----------------------------

FEATURES OF POSTGRES

	Multi-Version Concurrency Control (MVCC) architecture.
	Granular access controls
	Tablespaces
	Asynchronous replication
	Online/hot backups, write-ahead logging.
	Supports international character sets
	Highly scalable both in the quantity of data
	PostgreSQL''s write-ahead logging makes it a highly fault-tolerant database
	
- Open source 

*** Memory and process 

(See arch in word file)

Data Flow :

	- Application connects to the postmaster process.
	- The postmaster checks the application''s rights and, if successful, starts a new Postgres process and connects 
	  it with the client application.
	- The instance doesn''t write or read the requested data directly to or from disk files. Instead, it buffers them 
	  in a shared memory area called the shared buffers.
	- The Postgres process acts on the shared buffers and WAL buffers and manipulates their contents.
	- The client requests a Commit, and the WAL writer process writes and flushes all WAL records resulting from this
	  transaction to the WAL file. As the WAL file, in contrast to the data files, is written strictly sequentially,
	- Periodically, the background writer process checks the shared buffers for 'dirty' pages and writes them to the 
	  appropriate data files.
	- In essence, the instance contains at least three processes: WAL writer, background writer, and checkpointer, and 
	  one Postgres process per connection. In most cases, there are a few more processes running

Background Processes :

Process				Description
-------------		--------------------------------------------
Logger				Write the error message to the log file.
Checkpointer		When a checkpoint occurs, the dirty buffer is written to the file.
Writer				Periodically writes the dirty buffer to a file.
WAL Writer			Write the WAL buffer to the WAL file.
Autovacuum Launcher	Fork autovacuum worker when autovacuum is enabled.lt. It is the responsibility of the autovacuum 
					daemon to carry out vacuum operations on bloated tables on demand.
Archiver			When in Archive.log mode, copy the WAL file to the specified directory.
Stats Collector		DBMS usage statistics such as session execution information (pg_stat_activity) and table usage 
					statistical information (pg_stat_all_tables) are collected
					

Memory :

Memory TYPE			Description 
---------------		-------------------------------------------------		
Shared Memory		(database caching and transaction log caching)

Shared Buffer		- Minimizes DISK IO
					- Access very large (tens, hundreds of gigabytes) buffers quickly
					- Minimizes contention when many users access it at the same time
					- Frequently used blocks must be in the buffer for as long as possible

WAL Buffer 			- Temporarily stores changes to the database
					- Written to the WAL file
					- Useful for backup and recovery

Postmaster Process	- The Postmaster process is the first process started when you start PostgreSQL
					- At startup, performs recovery,
					- Initialize shared memory
					- Run background processes
					- It also creates a backend process when there is a connection request from the client process				
					
work_mem Space		 - Used for sorting, bitmap operations, hash joins, and merge joins. The default setting is 4 MB.
Maintenance_work_mem - Space used for Vacuum and Create Index. The default setting is 64 MB.
Temp_buffers		 - Space used for temporary tables. The default setting is 8 MB				


3.Installation of postgresql ------------------------------------------------------------------

Installation Directory: C:\Program Files\PostgreSQL\17
Server Installation Directory: C:\Program Files\PostgreSQL\17
Data Directory: C:\Program Files\PostgreSQL\17\data
Database Port: 5432
Database Superuser: postgres
Operating System Account: NT AUTHORITY\NetworkService
Database Service: postgresql-x64-17
Command Line Tools Installation Directory: C:\Program Files\PostgreSQL\17
pgAdmin4 Installation Directory: C:\Program Files\PostgreSQL\17\pgAdmin 4
Stack Builder Installation Directory: C:\Program Files\PostgreSQL\17
Installation Log: C:\Users\oline\AppData\Local\Temp\install-postgresql.log

user postgres/postgres



------------- Step 1 : Installing PostgreSQL on Linux 7.5

You can see installation steps on postgresql site : https://www.postgresql.org/download/linux/redhat/

Summary below :

	yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86-64/pgdg-redhat-repo-latest.noarch.rpm  --repo
	yum install postgresql12			-- client
	yum install postgresql12-server		-- server

	/usr/pgsql-12/bin/postgresql-12-setup initdb	-- Initialize the db
	systemctl enable postgresql-12					-- Allow postgresql start when system restarts
	systemctl start postgresql-12
	systemctl status postgresql-12

------------- Step 2 :  USING POSTGRESQL ROLE

The installation procedure created a user account called postgres that is associated with the default Postgres role
and a a sudo user.

SWITCH to POSTGRES ACCOUNT
#sudo -u postgres

You can now access a Postgres prompt by typing below command:

$psql
postgres# \du 	: displays all roles/users available  -- there is a role colled "postegres" which is superuser

postgres# \q	: to exit psql

------------- Step 3 : CREATING A NEW NON DEFAULT ROLE.

You have the postgres role configured within the database.
You can create new roles from the command line with the createrole command. 
The "--interactive" flag will prompt you for the name of the new role and also ask whether it should have superuser 
permissions.

If you are logged in as the postgres account. 

-bash-4.2$ createuser-interactive
Enter name of role to add: testuser
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) n
Shall the new role be allowed to create more new roles? (y/n) n

-bash-4.2$

$sudo -i -u postgres 

connect to 


4.MANAGING TABLESPACES ------------------------------------------

pg_default :tablespace stores all user data.
pg_global : tablespace stores all global data (dictionnaire)

---------- DEFAULT STORAGE IN POSTGTRESQL

pg_ctl -D data initdb
Is -IF data
pg_ctl -D data start

When you initialize postgre, the Postgres server creates the required files in $PGDATA directory 

The Default Tablespaces

Two tablespaces are automatically created when the database cluster is initialized.

pg_global  : tablespace is used for shared system catalogs.
pg_default : tablespace is the default tablespace for users and also for templatel and template0 databases

--- Creating a new tbs

postgres# create tablespace tbs1 location '/postgres/data/tbs1';
postgres# \db+
Is -l data/pg_tblspc/

Creating Objects :

create database dbl tablespace tbs1;
\c dbl					-- Switch to db : db1

create table tabl (a int);
create table tab2 (a int) tablespace tbs2;
create table tab3 (a int) tablespace pg_default;

---- Demo 

Initialize an instance :  1

$ sudo su - postgres
$ mkdir -p /postgres/data/instancel
$ pg_ctl -D /postgres/data/instancel initdb  *

Start the database server using : 2

$ pg_ctl -D /postgres/data/instancel start
or 
$ pg_ctl -D /postgres/data/instancel -l logfile start  *

$ pg_ctl -D data initdb
Is -lF data
pg_ctl -D data start

 \db+
    Name    |  Owner   |          Location           | Access privileges | Options |  Size   | Description
------------+----------+-----------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                             |                   |         | 22 MB   |
 pg_global  | postgres |                             |                   |         | 565 kB  |
 
postgres@OlivierLP:~/16/data$ pwd
/var/lib/postgresql/16/data
postgres@OlivierLP:~/16/data$ psql
psql (16.4 (Ubuntu 16.4-0ubuntu0.24.04.2))
Type "help" for help.

postgres=# create tablespace tbs1 location '/var/lib/postgresql/16/data';
CREATE TABLESPACE

postgres=# \db+		: see all tbs
                                            List of tablespaces
    Name    |  Owner   |          Location           | Access privileges | Options |  Size   | Description
------------+----------+-----------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                             |                   |         | 22 MB   |
 pg_global  | postgres |                             |                   |         | 565 kB  |
 tbs1       | postgres | /var/lib/postgresql/16/data |                   |         | 0 bytes |
(3 rows)

postgres=# exit
postgres@OlivierLP:~/16/data$ ls -ltrh
total 4.0K
drwx------ 2 postgres postgres 4.0K Nov  8 22:33 PG_16_202307071
postgres@OlivierLP:~/16/data$

***** pg_tblspc : folder in $PGDATA where you have symbolic links to tablespaces folders associated with tablespaces 

postgres@OlivierLP:~/16/main$ ls
PG_VERSION  pg_commit_ts  pg_multixact  pg_serial     pg_stat_tmp  pg_twophase  postgresql.auto.conf
base        pg_dynshmem   pg_notify     pg_snapshots  pg_subtrans  pg_wal       postmaster.opts
global      pg_logical    pg_replslot   pg_stat       pg_tblspc    pg_xact      postmaster.pid
postgres@OlivierLP:~/16/main$ cd pg_tblspc
postgres@OlivierLP:~/16/main/pg_tblspc$
postgres@OlivierLP:~/16/main/pg_tblspc$ ls -ltrh
total 0
lrwxrwxrwx 1 postgres postgres 27 Nov  8 22:33 16390 -> /var/lib/postgresql/16/data

NB : l''id pour le nouveau tbs est : 16390


***** Create database with default tbs :

postgres=# create database db1 tablespace tbs1;
postgres=# \l
                                                   List of databases
   Name    |  Owner   | Encoding | Locale Provider | Collate |  Ctype  | ICU Locale | ICU Rules |   Access privileges
-----------+----------+----------+-----------------+---------+---------+------------+-----------+-----------------------
 db1       | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           |
 postgres  | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           |
 template0 | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           | =c/postgres          +
           |          |          |                 |         |         |            |           | postgres=CTc/postgres
 template1 | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           | =c/postgres          +
           |          |          |                 |         |         |            |           | postgres=CTc/postgres
(4 rows)

postgres@OlivierLP:~/16/main/pg_tblspc$ mkdir -p /var/lib/postgresql/16/data/tbs2
postgres=# create tablespace tbs2 location '/var/lib/postgresql/16/data/tbs2';
CREATE TABLESPACE


postgres=#

***** switch to db1 and create tables 

postgres=# \c db1
You are now connected to database "db1" as user "postgres".

db1=# create table tabl (a int);
CREATE TABLE
db1=#

postgres=# \db+
                                              List of tablespaces
    Name    |  Owner   |             Location             | Access privileges | Options |  Size   | Description
------------+----------+----------------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                                  |                   |         | 22 MB   |
 pg_global  | postgres |                                  |                   |         | 565 kB  |
 tbs1       | postgres | /var/lib/postgresql/16/data      |                   |         | 7568 kB |
 tbs2       | postgres | /var/lib/postgresql/16/data/tbs2 |                   |         | 0 bytes |
(4 rows)

postgres=# create table tab2 (a int) tablespace tbs2;
CREATE TABLE
postgres=# create table tab3 (a int) tablespace pg_default;
CREATE TABLE
postgres=# \db+
                                                List of tablespaces
    Name    |  Owner   |             Location             | Access privileges | Options |    Size    | Description
------------+----------+----------------------------------+-------------------+---------+------------+-------------
 pg_default | postgres |                                  |                   |         | 22 MB      |
 pg_global  | postgres |                                  |                   |         | 565 kB     |
 tbs1       | postgres | /var/lib/postgresql/16/data      |                   |         | 7568 kB    |
 tbs2       | postgres | /var/lib/postgresql/16/data/tbs2 |                   |         | 4096 bytes |
(4 rows)

postgres=#

***** ******** How to move objects from one tablespace to another

NB: There will be a lock on the table while moving to another tbs

alter table tabl set tablespace pg_default;
alter table all in tablespace tbs1 set tablespace pg_default;

*********** Tablespace Properties

alter tablespace space2 set (seq_page_cost=0.5, random_page_cost=0.5);   -- No tested : Need to check further

*********** Set default tablespace for users

postgres=# SET default_tablespace = tbs2;
SET
postgres=# show default_tablespace ;
 default_tablespace
--------------------
 tbs2
(1 row)

postgres=# create table foo (i int);
CREATE TABLE
postgres=# select * from pg_tables where tablename='foo';
 schemaname | tablename | tableowner | tablespace | hasindexes | hasrules | hastriggers | rowsecurity
------------+-----------+------------+------------+------------+----------+-------------+-------------
 public     | foo       | postgres   | tbs2       | f          | f        | f           | f
(1 row)

postgres=# select relname,reltablespace from pg_class where reltablespace in(select
oid from pg_tablespace where spcname not in ('pg_default','pg_global'));
 relname | reltablespace
---------+---------------
 tab2    |         16397
 foo     |         16397
 tab1    |         16390
(3 rows)

postgres=# select * from pg_tablespace;
  oid  |  spcname   | spcowner | spcacl | spcoptions
-------+------------+----------+--------+------------
  1663 | pg_default |       10 |        |
  1664 | pg_global  |       10 |        |
 16390 | tbs1       |       10 |        |
 16397 | tbs2       |       10 |        |
(4 rows)

postgres=# select  relname,reltablespace from pg_class where relname like 'tab%';

      relname      | reltablespace
-------------------+---------------
 tab1              |         16390
 tab2              |         16397
 tab3              |             0
 table_constraints |             0
 table_privileges  |             0
 tables            |             0
(6 rows)

***********  How to Backup additional tablespace

pg_basebackup --format=p --tablespace-mapping=/tmp/space2=/tmp/space2backup -D plainb

*********** Why is tablespace is used for

- Database growing then create a new tablespace and move objects from existing to new tablespace. 
- High perfomrming disk move indexes and table to that

5.How to change data directory --------------------------------------------------

postgres=# show data_directory;
       data_directory
-----------------------------
 /var/lib/postgresql/16/main
(1 row)

postgres=#  

New datadir location: /postgres/data

***********  STEP 2 - SHUTDOWN POSTGRES SERVICE.
Depending on postgresql installed :

sudo systemctl status postgresql-12    
sudo systemctl stop postgresql-12 
sudo systemctl status postgresql-12

or 

If postgre user already in sudoers, no need to add sudo at the beginning :

$ service postgresql status
$ service postgresql stop
$ service postgresql status

***********  STEP 3 Copy/move data from current data directory to new location.

#chown postgres: postgres /postgres/data 
$chmod -R 750 /postgres/data

cd /var/lib/pgsql/12/data/ 
cp -r * /postgres/data 
cd /postgres/data
ls -lrt

***********  Step 4 Update New Data dir Location in config file. ***

cp /var/lib/pgsql/12/data/postgresql.conf /var/lib/pgsql/12/data/postgresql.conf_orig

sudo vi /var/lib/pgsql/12/data/postgresql.conf

data_directory = '/postgres/data/'

***********  Step 5 Restarting Postgres ***********  

sudo systemctl start postgresql-12
sudo systemctl status postgresql-12

or 

$ service postgresql stop
$ service postgresql status

tail -10f /var/log/messages

***********  Step 6 Verify new location ***

sudo u postgres psql 
SHOW data_directory;

postgres=# SHOW data_directory; 
data_directory
/postgres/data (1 row)


6.Introduction to PostgreSQL log_statement ----------****************************************************

- It''s related to error and error reporting, along with warnings and database queries in a logfile.
- The default log_statement option in the PostgreSQL configuration file is none, which means nothing will be logged 
  into the error file.

	Options:
		NONE
		DDL 
		MOD
		ALL

How does log_statement work in PostgreSQL?

- It''s a useful parameter in PostgreSQL used to log errors in the logfile, database warning messages, and SQL queries.
- Log_statements have four options available in PostgreSQL, as mentioned below.

None:
	- This option of log_statement is defined as not logging any query in the error log file.
	- This is the default configuration option of log_statement available. This is also defined as turning off the 
	  log_statement parameter for PostgreSQL.
DDL: 
	- Log all queries that are under the category of the DDL statement.
		E.g., create, alter, and drop statements.
A11:
	- This option is defined as logging all statements executed by the user
	- It is logging DDL, DML, and all the query language in PostgreSQL.
	- Not advised

Mod:
	- This option in log_statement is defined as log DDL query as well as log the modifying statement like delete, 
	  update, truncate, insert, copy, execute, and prepare

Example #1  Log statement with none options.**************************

It will not log anything into the error log.

psql script:

show log statement;

create table course (course_no integer, name text, price numeric); 
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, "mysql", 160),
	(3, 'mongodb', 170);

select from course;

tail -10f postgresql-***.log

Example #2  Log statement using DOL options. **************************

In the following example, we have used DDL options with the log statement parameter. It will log only the DDL 
statement into the error log.

Psql script:

alter system, set log statement 'DDL';

$sudo systemctl restart postgresql-12 

$psql
postgres# show log statement;

	log_statement
	--------
	ddl
	(1 row)

CREATE TABLE course (course_no integer,name, text,price, numeric);
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, 'mysql', 160),
	(3, 'mongodb', 170);

postgres# select from course;

course_no	name		price

1			postgres	150
2			mysql		160
3			mongodb		170
(3 rows)

delete from course;

Example #3 Log statement using ALL options. **************************

In the example below, we have used ALL options with the log statement parameter. It will log all statements 
into the error log.

Psql script:

alter system set log statement "ALL";

show log statement;

CREATE TABLE course (course_no integer,name text,price numeric);
select * from course;

Example #4  Log statement using mod options.  **************************

In the following example, we have used mod options with the log statement parameter. It will log DDL and DML 
into the error log.

Psql script:

alter system set log statement 'mod';
$sudo systemctl restart postgresql-12 

$psql
postgres# show log statement;

explain select * from courses;
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, "mysql", 160),
	(3, 'mongodb', 170);

tail -10f postgresql-Mon.log

8.Repmgr (Replication & Failover Management) **************************

**** Streaming Replication in PostgreSQL (2 EC2 PostgreSQL-13)******

Postgres replication is the process of copying data from one database host (primary) to another database host 
(standby).

In version 9.0 (back in 2010), streaming replication was introduced.

- Streaming replication in PostgreSQL works on log shipping.
- Every transaction in PostgreSQL is written to a transaction log called WAL (write-ahead log) to achieve 
  durability.
- A slave uses these WAL segments to continuously replicate changes from its master.

In streaming replication, three kinds of processes work cooperatively.
	- A WAL sender process on the primary server sends WAL data to the standby server;
	- and then, a WAL receiver and a startup process on the standby server receives and replays this data.
	- A WAL sender and a WAL receiver communicate using a single TCP connection.

PostgreSQL is a widely used relational database that supports both logical and physical replication:

- Logical replication streams high-level changes from the primary database cluster to the replica databases.
  Using logical replication, you can stream changes to just a single database or table in a database.

- In physical replication, changes to the WAL (Write-Ahead-Logging) log file are streamed and replicated in the 
 replica clusters. As a result, you can''t replicate specific areas of a primary database cluster; instead, all 
 changes to the primary are replicated


Overview of REPMGR ****************************

repmgr is an open-source tool for managing replication and failover of PostgreSQL servers.
It supports and enhances PostgreSQL''s built-in streaming replication which provides a single read/write 
primary server and one or more read-only standbys containing near-real-time copies of the primary server''s 
database.

It provides two main tools:

	1) repmgr:

		A command-line tool used to perform administrative tasks such as:

		Setting up standby servers.
		Promoting a standby server to primary.
		Switching between primary and standby servers.
		Displaying the status of servers in the replication cluster.

	2) repmgrd:

		A daemon that actively monitors servers in a replication cluster and performs below:
		 - Monitoring and recording replication performance
		 - Performing failover by detecting failure of the primary and promoting the most suitable standby server

Repmgr User and Metadata

Repmgr needs to store information about the servers in the cluster in a schema.
This schema is automatically created by the Repmgr extension which is installed during the first step in 
initializing a Repmgr-administered cluster (Repmgr primary register) and contains the following objects:

Tables :

	Repmgr.events: Records events of interest
	Repmgr.nodes: Connection and status information for all hosts of the cluster.
	Repmgr.monitoring_history: Historical standby monitoring information.

Views :

  Repmgr.show_nodes: Based on the Repmgr.nodes table, additionally showing name of the server''s upstream node.
  Repmgr.replication_status: When Repmgr''s monitoring is enabled, shows current monitoring status for each stan...
  The Repmgr metadata schema can be stored in an existing database or in its own dedicated database. Note that 
     the Repmgr metadata schema cannot reside on a database server that is not part of the replication c... 
	 managed by Repmgr

A database user must be available to access this database and make necessary changes
This user does not need to be a superuser, however some operations such as the initial installation of the 
  repmgr extension will require a superuser connection (this can be specified where required with the co...

Installation of REPMGR
-----------
  repmgr can be installed from binary packages provided by your OS packaging system, or from source.

Requirements for installing repmgr
-----------
	All cluster servers have the same major version of PostgreSQL, same minor version.

	repmgr must be installed on each server in the replication cluster.
	If installing repmgr from packages, the package version must match the PostgreSQL version.
	If installing from source, repmgr must be compiled against the same major version.

Installing repmgr from packages
-----------
repmgr RPM packages for RedHat/CentOS variants and Fedora are available from the 2ndQuadrant public repository;

sudo yum install repmgri1

Prerequisites for setting up a basic replication cluster with repmgr
-----------
We''ll assume the
	primary is called node with IP address 192.168.1.51
	standby is called node2 with IP address 192.168.1.61

	Following software must be installed on both servers:
		PostgreSQL
		repmgr (matching the installed PostgreSQL major version)

At the network level
-----------
	- Connections between the PostgreSQL port (default: 5432) must be possible in both directions.
	- If you want repmgr to copy configuration files which are located outside the PostgreSQL data directory,
	    and/or to test switchover functionality,you need passwordless SSH connections between both servers, 
	    and rsync should be installed

PostgreSQL Configuration
-----------
On the primary server, a PostgreSQL instance must be initialized and running.
The following replication settings may need to be adjusted:

# Enable replication connections; set this value to at least one more than the number of standbys that will connect 
# to this server. (Note that repmgr will execute "pg_basebackup" in WAL streaming mode which requires two free 
# WAL senders).

max_wal_senders = 10

# If using replication slots, set this value to at least one more than the number of standbys that will connect to 
# this server. Note that repmgr will only make use of replication slots if "use_replication_slots" is set to "true" in
# "repmgr.conf". (If you are not intending to use replication slots, this value can be set to "0").

max_replication_slots = 10  -- used in our case

# Ensure WAL files contain enough information to enable read-only queries on the standby.
# PostgreSQL 9.5 and earlier: one of 'hot_standby' or 'logical'
# PostgreSQL 9.6 and later: one of 'replica' or 'logical'
# ('hot_standby' will still be accepted as an alias for 'replica')

wal_level = 'hot_standby'

# Enable read-only queries on a standby
# (Note: this will be ignored on a primary, but we recommend including it anyway, in case the primary later becomes 
# a standby)

hot_standby = on

# Enable WAL file archiving

archive_mode = on

# Set archive command to a dummy command; this can later be changed without needing to restart the PostgreSQL instance.

archive_command = '/bin/true'

Create the repmgr user and database
----------------------
createuser -s repmgr
createdb repmgr -0 repmgr
ALTER USER repmgr SET search_path TO repmgr, "$user", public;

Configuring authentication in pg_hba.conf
--------------------------------------------
Ensure the repmgr user has appropriate permissions in pg_hba.conf and can connect in replication mode;
pg_hba.conf should contain entries similar to the following:  [6 lines important for replication]

	local	replication	repmgr					trust
	host	replication	repmgr	127.0.0.1/32	trust
	host	replication	repmgr	192.168.1.0/24	trust

	local	repmgr		repmgr					trust
	host	repmgr		repmgr	127.0.0.1/32	trust
	host	repmgr		repmgr	192.168.1.0/24	trust

Preparing the standby
----------------
	- Do not create a PostgreSQL instance (i.e., do not execute initdb), but do ensure the destination data directory 
	  (and any other directories you want PostgreSQL to use) exist and are owned by the Postgres system user.
	- Permissions must be set to 0700 (drwx------).
	- Check the primary database is reachable from the standby using psql:

	  psql 'host=node1 user=repmgr dbname=repmgr connect_timeout=2'

repmgr configuration file Primary
----------------
  Create a repmgr.conf file on the primary server. The file must contain at least the following parameters:

	node_id=1
	node_name='node1'
	conninfo='host=node1 user=repmgr dbname=repmgr connect_timeout=2'
	data_directory='/var/lib/postgresql/data'

  repmgr.conf should not be stored inside the PostgreSQL data directory, as it could be overwritten when setting up
  or reinitializing the PostgreSQL server.

Register the primary server
----------------
To enable repmgr to support a replication cluster, the primary node must be registered with repmgr. This installs the 
repmgr extension and metadata objects, and adds a metadata record for the primary server:

	$ repmgr -f /etc/repmgr.conf primary register   --repmgr.conf has the 4 params above

	INFO: connecting to primary database..
	NOTICE: attempting to install extension "repmgr"
	NOTICE: "repmgr" extension successfully installed
	NOTICE: primary node record (id: 1) registered

Verify the status of the cluster like this:

$ repmgr -f /etc/repmgr.conf cluster show

ID	Name	Role 	|Status 	|Upstream |Connection string
-------------------------------------------
1	node1	primary |* running |		  | host node1 dbname=repmgr user repmgr connect_timeout=2

The record in the repmgr metadata table will look like this:

	repmgr=# SELECT * FROM repmgr.nodes;
	
	-[ RECORD 1]---+--------------
	node_id				1
	upstream_node_id	
	active				t
	node_name			node1
	type				primary
	location			default
	priority			100
	conninfo			host node1 dbname=repmgr user repmgr connect_timeout=2
	replzer				repmgr
	slot_name
	config_file			/etc/repmgr.conf

Each server in the replication cluster will have its own record.
If repmgrd is in use, the fields upstream_node_id, active, and type will be updated when the node''s status or role 
  changes.

Clone the standby server
-----------------
Create a repmgr.conf file on the standby server. It must contain at least the same parameters as the primary''s 
repmgr.conf, but with the mandatory values node, node_name, conninfo (and possibly data_directory) adjusted 
accordingly, e.g.:

	node_id=2
	node_name='node2'
	conninfo='host=node2 user=repmgr dbname=repmgr connect_timeout=2'
	data_directory='/var/lib/postgresql/data'

Use the -dry-run option to check the standby can be cloned:

	$ repmgr -h node1 U repmgr -d repmgr -f /etc/repmgr.conf standby clone --dry-run

	NOTICE: using the provided configuration file "/etc/repmgr.conf"
	NOTICE: destination directory "/var/lib/postgresql/data" provided
	INFO: connecting to source node
	NOTICE: Checking for available walsenders on source node (2 required)
	INFO: Sufficient walsenders available on source node (2 required)
	NOTICE: Standby will attach to upstream node 1
	HINT: Consider using the -c/--fast-checkpoint option
	INFO: All prerequisites for "standby clone" are met

	$ repmgr -h node1 U repmgr -d repmgr -f /etc/repmgr.conf standby clone  //run effectiveliy

This has cloned the PostgreSQL data directory files from the primary node 1 using PostgreSQL''s pg_basebackup utility.
A recovery.conf file containing the correct parameters to start streaming from this primary server will be created 
automatically.

Note
------
By default, any config files in the primary''s data directory will be copied to the standby.Typically, these will be

	postgresql.conf,
	postgresql.auto.conf,
	pg_hba.conf, and
	pg_ident.conf.

These may require modification before the standby is started.
Make any adjustments to the standby''s PostgreSQL configuration files now, then start the server	
	
Verify replication is functioning
------------------------------------
Connect to the primary server and execute:

	repmgr=# SELECT * FROM pg_stat_replication;

This shows that the previously cloned standby (node2 shown in the application_name field) has connected to the primary
from its IP address...

From PostgreSQL 9.6, you can also use the pg_stat_wal_receiver view to check the replication status from the standby.

	repmgr=# SELECT * FROM pg_stat_wal_receiver;

Note that the conninfo value is generated in recovery.conf and will differ slightly from the primary''s conninfo as 
set in repmgr.

Register the standby
--------------
Register the standby server with:

	$ repmgr -f /etc/repmgr.conf standby register

	NOTICE: standby node "node2" (ID: 2) successfully registered

Check the node is registered by executing repmgr cluster show on the standby:

	$ repmgr -f /etc/repmgr.conf cluster show

	ID 	|Name 	|Role 	|Status |Upstream |Location |Priority |Timeline |Connection string
	-----------------------------------------------------------------
	1 	node1	primary	 running |		  |default	 100		1		| host=node1 dbname=repmgr user=repmgr
	2 	node2	standby |running  node1	  | default |100		1		| host=node2 dbname=repmgr user=repmgr

Both nodes are now registered with repmgr and the records have been copied to the standby server.

Demo pending ...coming ASAP

9.PSQL CHEATSHEET.  [Usual commands]-------------------------------------------------------------------------------

How to Connect to psql Locally on Linux

1# sudo u postgres psql
or
2. # sudo su postgres

	2a. $ psql U postgres -p 5432 -W    <- Option -W prompts for the password
	2b. $ psql U postgres -p 5432 -w	<- Option -w to login without password
	2c. $ psql

3. How to connect psql remotely from the command line.

Note: psql is built as a "console application." Since the Windows console, windows use a different encoding than the rest of the system.

chcp 1252

cd C:\Program Files\PostgreSQL\12\bin
psql -U postgres p 5432 h 192.168.1.61 -W	<- To connect remotely 
  password

4. \d

5.	\1: List databases
	\c dbname "Connect to a database"
	psql -h 192.168.1.61 p 5432 U postgres dvdrental

6. Tables related commands
	\dt						: list of tables of connected db
	\c dvdrental
	\dt
	\d tablename  : Show table definition (columns, etc.) including triggers
	\d+ tablename : More detailed table definition including description and physical disk size.
	\dt *.*

postgres # select * from pg_catalog.pg_tables where schemaname != 'pg_catalog' and schemaname != 'information_schema';

7.  \di 	 :List indexes
	\d actor : Lists indexes of a particular table 

postgres # SELECT tablename, indexname, indexdef from pg_indexes WHERE tablename LIKE '%actor%' ORDER BY tablename, indexname;

8. \dn: List schemas
	CREATE SCHEMA myschema;
	DROP SCHEMA myschema;
	DROP SCHEMA myschema CASCADE;
	
9.	\dy: List events
	\df: List functions
	\df+ <function_name> Show function SQL code.
	\dT+: List all data types
	\dv: List views
	\dx: List all extensions installed
	\x: Pretty-format query results instead of the not-so-useful ASCII tables
	\copy (SELECT FROM_table_name) TO 'file_path_and_name.csv' WITH CSV: Export a table as CSV
	\copy (SELECT * FROM actor) TO 'c:\actor.csv' WITH CSV: Export a table as CSV
	\des+: List all foreign servers
	\dE[S+]: List all foreign tables

10.	\du: List users
	\du appreporting_user1: List a username if present.

	set role appreporting_user1; Change the role for the current session to testuser.

	\deu+: List all user mappings on the server

10.Postgresql on Docker -------------------------------------------------------------------------------

HOW TO INSTALL POSTGRESQL ON DOCKER

Uninstall Old Versions of Docker:
	sudo apt-get remove docker docker-engine docker.io

Docker installation on Ubuntu: 
	sudo apt-get update

How to install Docker on Ubuntu: sudo apt install docker.io

Start and automate Docker on host reboot

	sudo systemctl start docker
	sudo systemctl enable docker
	sudo systemctl status docker

How to check docker version
	docker --version

Step to pull Postgres image and the container. Let''s pull postgres image onto Ubuntu system from docker hub.
	sudo docker pull postgres

How to verify all existing Docker images.
	sudo docker images

Once verified, start the Postgres instance.

	sudo docker run -name postgres-docker_3e POSTGRES_PASSWORD=password -p 5433:5433 -d postgres
	sudo docker run -name postgres-docker_2e POSTGRES_PASSWORD=password p 5434:5434 d postgres

Check Docker for the containers that are running.

	sudo docker ps

Connect with the Docker Postgres container and connect to the psql command.

	sudo docker exec -it postgres-0 psql -U postgres
	sudo docker exec -it postgres-docker_2 psql -U postgres

--- additional commands 

Check Docker version.
	sudo docker-version

How to download Docker image.
	sudo docker pull image_name

How to list down all existing images installed.
	sudo docker images

How to run Docker image:
	sudo docker run itd image_name

How to check which container is running in Docker.
	sudo docker ps

To list all Dockers with status and with the container info.
	sudo docker ps -a

How to access Docker container:
	sudo docker exec it container_id bash

How to remove a Docker container.
	sudo docker rm container_id

To remove a particular image.
	sudo docker rmi image_id

How to restart a Docker container.
	sudo docker restart container_id

How to stop a Docker container.
	sudo docker stop container_id


12.PostgreSQL internat authentication -------------------------------------------------------------------------------

PostgreSQL manages internal authentication mechanisms as mentioned in the pg_hba.conf file

cat pg_hba.conf|grep i method

	# METHOD can be "trust", "reject", "md5", "password", "scram-sha-256",
	# Authentication methods refer to the "Client Authentication"

	Note: This is an inter-process communication mechanism that allows bidirectional data exchange between processes 
	running on the ...

	Column of all pg_hba.conf
	--------------------

	# TYPE		DATABASE		USER		ADDRESS		METHOD
	# "local" is for Unix domain socket connections only
	local		all				all						 peer

	# IPv4 local connections:
	host		all				all			127.0.0.1/32 ident

	# IPv6 local connections:
	host		all				all			::1/128		 ident

Column 1:Local is used by Unix-Domain socket. If it is a host, mention the host IP address in the address column.
Column 2: Used for the database; mention the database name.
   If it has been set to all, then all the databases in the PostgreSQL cluster will use the same auth mechanism.
Column 3: It is the user. It can be set to separate auth methods for different users, and "all" means for all users.
Column 4: IP address. For example, the IP address can use a particular authentication method.
Column 5: Which auth mode of authentication has to be used

NB: Different Methods :***********

-bash-4.2$ cat $PGDATA/pg_hba.conf|grep i method

local		DATABASE 	USER 	METHOD 		[OPTIONS]
host 		DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostssl 	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostnossl	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostgssenc	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostnogssenc DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS] 

Method can be "trust", "reject", "md5", "password", "scram-sha-256", authentication methods -- refer to the 
"Client Authentication"
********************************

Auth method Trust
--------------------
A user mentioned with trust does not require any password for authentication.

Example-1

# TYPE	DATABASE	USER	ADDRESS			METHOD

host	all			all		127.0.0.1/32	trust   <- Any conn from localhost will go through trust auth method and will be accepted

Example-2

# TYPE	DATABASE	USER	ADDRESS			METHOD

host	all			all		127.0.0.1/32	reject <- Any host that is not localhost will have the connection rejected.

Testing
	Trust Authentication
	--------------------
		Login From localhost
			postgres@127.0.01:~$ psql postgres -h 127.0.0.1 -U postgres

	Reject Authentication
	--------------------
	Login From Remote Host
		postgres@IP~$ psql postgres -h IP U postgres
		psql: error: could not connect to server:
		FATAL: pg_hba.conf rejects connection for host "IP", user "postgres", database "postgres"

md5 Authentication
--------------------
When using md5 authentication, you must provide the password.

Example

host	database	user 	address			auth-method
host	all			all		127.0.0.1/32	md5

testing
	psql postgres -h IP -U postgres

SCRAM Authentication
--------------------
It is one of the most secure authentication methods, using cryptographically hashed security mechanisms to store 
passwords on the system.

testing
	SET password encryption = 'scram-sha-256';
	
	ALTER USER postgres WITH PASSWORD 'password';

Modify hab.conf as below

host 	database 	user 	address		auth-method
host	all			all		IP/32		<span class="s1">scram-sha-256</span>

psql postgres -U postgres

13.Backup and Restore using pg_basebackup ------------------------------------------------------------------------

How to backup and restore using pb_basebackup on the same host
pg_basebackup is used to backup all the cluster and not only a db

Step-by-step backup and restoration using pb_basebackup

Prerequisites
-----------------
EC2 RHEL instance ready with access
Sample database dvdrental loaded.

psql

postgres# show data_directory

	 data directory
	---------------------------------
	/var/lib/pgsql/13/data 
	(1 row)

postgres#\db+
		List of tablespaces

	Name		Owner	Location	Access privileges 	Options Size		Description 
	------		-----	----------	-----------------	-----	---------	------------------
	pg_default	postgres										1879 MB
	pg_global	postgres										1583 kB

	(2 rows)

\l+

dvdrental_99+=# show config_file;

	config file
	-------------------------------------
	/var/lib/pgsql/13/data/postgresql.conf

	(1 row)

vi /var/lib/pgsql/13/data/postgresql.conf

archive_mode=on
archive timeout=300
archive_command='archive_command | test ! -f /var/lib/pgsql/13/data/pg_wal/%f && cp %p /var/lib/pgsql/13/backups/pg_wal/%f'
archive_cleanup_command=''

edit and save the file.

Restart the postgresql13

	postgres$ sudo systemctl restart postgresql-13

	psql show archive_mode;
	show archive_timeout;
	show archive_command;
	show archive_cleanup_command;

dvdrental 99+# select name, setting, unit from pg_settings where name like 'archive%';

		name					|setting 																									|unit
		----------------		--------------------------------------------------------------------------------------------------------	------
		archive_cleanup_command
		archive command			archive_command | test ! -f /var/lib/pgsql/13/data/pg_wal/%f && cp %p /var/lib/pgsql/13/backups/pg_wal/%f
		archive_mode			 on
		archive_timeout			 300	<-- 5 mn																									 s
		
		
Post verification let''s forcefully switch the wasl logfiles;

	psql

	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();

	alter user postgres password 'password';

Initiate a compressed pg basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup

	pg_basebackup -h localhost -p 5432 -U postgres -D /var/lib/pgsql/pg_backup -Ft -z -Xs -P  <-- local backup


	-D,	--pgdata=DIRECTORY				receive base backup into directory
	-F,	--format=p|t					output format (plain (default), tar)
	-X,	--xlog							include required WAL files in backup (fetch mode)
	-X,	--xlog-method=fetch | stream	include required WAL files with specified method    (nb: stream is used for continious shipping for repl)
	-Z,	--gzip							compress tar output
	-Z,	--compress=0-9					compress tar output with given compression level  (0: no compress and 9:highest)
	-l,	--label-LABEL					set backup label
	-P,	--progress						show progress information
	-v,	--verbose						output verbose messages
	-V,	--version						output version information, then exit
	-?,	--help							show this help, then exit

	-X		--wal-method=none 			fetch stream  ??
	
Connection options:

	-h,	--host-HOSTNAME					database server host or socket directory
	-P,	--port=PORT						database server port number
	"-s"--status-interval				Time between status packets sent to server (in seconds)
	-U,	--username=NAME					Connect as specified database user
	-W,	--no-password					Never prompt for password
	-W,	--password						Force password prompt (should happen automatically)

	$ pq_basebackup -h localhost -p 5432 -U postgres -D/var/lib/pgsql/pg_backup -Ft-z-Xo -P
	915653/915653 kB (100%), 1/1 tablespace

	[postgres@pg pg backup]$ ls -lrt
	total 127244
	-rw------ 1 postgres postgres 125726001 Oct 1 08:14 base.tar.gz
	-rw------ 1 postgres postgres   4548337 Oct 1 08:14 backup_manifest 
	-rw------ 1 postgres postgres     17087 Oct 1 08:14 pg_wal.tar.gz

Initiate an uncompressed pg_basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup_uncompressed

Initiate an uncompressed pg_basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup_uncompressed  (remove the -z option)

	pg_basebackup -h localhost -p 5432 -U postgres -D/var/lib/pgsql/pg_backup_uncompressed -Ft -Xs -P

Verify that the uncompressed backup has been taken
------------------
ls -lrt /var/lib/pgsql/pg_backup_uncompressed

Let''s perform a disaster testing by cleaning up all the datafiles

	psql# show data_directory;

		/var/lib/pgsql/13/data

	$sudo systemctl stop postgresql-13
	$sudo systemctl status postgresql-13
	rm -rf /var/lib/pgsql/13/data

Start restoration using backup that was taken previously
------------------

Since we do not have any tablespace other than the default one, continue with the below untar command.

Restore backup backup

	cd /var/lib/pgsql/pg_backup
	mkdir -p /var/lib/pgsql/13/data
	gunzip base.tar.gz
	tar -xvf base.tar -C /var/lib/pgsql/13/data

Restore wal backup

	cd /var/lib/pgsql/pg_backup
	gunzip pg_wal.tar.gz
	mv /var/lib/pgsql/13/data/pg_wal /var/lib/pgsql/13/data/pg_wal_old
	mkdir -p /var/lib/pgsql/13/data/pg_wal
	tar -xvf pg_wal.tar -C /var/lib/pgsql/13/data/pg_wal

Restore if any non-default tabs are found

Skip to next step if not feasible

Restore wal backup to the default location

	vi /var/lib/pgsql/13/data/postgresql.conf

	Search for restore_command
	Uncomment restore_command and add below

	cp /var/lib/pgsql/13/data/pg_wal/%f %p

archive_command | paste here

restore_command = 'cp /var/lib/pgsql/13/backups/pg_wal/%f /var/lib/pgsql/13/data/pg_wal/%p'

Command to use to restore an archive

Try starting the service and verify if everything is working well
------------------
	sudo systemctl status postgresql-13

To check the issue during startup of restored PostgreSQL, use this:

	sudo tail -100f /var/log/messages
	sudo systemctl start PostgreSQL-13
	chmod 700 "/var/lib/pgsql/13/data"

From here onwards, all logs will be written to the log in the PostgreSQL data_directory

psql

\l

14.PostgreSQL-CREATE Database ------------------------------------------------------*********************

	1. Using CREATE DATABASE.
	2. Using createdb, a command-line utility

Using CREATE DATABASE
--------------------
This command will create a database on PostgreSQL (psql).

If you have appropriate privileges to create a database, by default, the new database will be created by copying the system database template 1.

Syntax:

The basic syntax of the CREATE DATABASE statement is as follows:

	CREATE DATABASE dbname;

	where dbname is the name of the database to create.

Example:

It creates testdb in your PostgreSQL schema.

	postgres# CREATE DATABASE testdb;



Using createdb Command
--------------------

The executable createdb is a utility for CREATE DATABASE.

The only difference between createdb and PSO CREATE DATABASE is that the former can be run directly from the 
command line and it allows a comment to be added to the database, all in one command.

Syntax:

The syntax for createdb is as shown below:

	createdb [option...] [dbname [description]]

The table given below lists the parameters with their descriptions.

S. No. Parameter & Description

	1 dbname: The name of a database to create.
	2 description: Specifies a comment to be associated with the newly created database.
	3 options: Command-line arguments, which createdb accepts.
	No. Option & Description

	 -D tablespace :Specifies the default tablespace for the database.
	 -e Echo the commands that createdb generates and sends to the server.
     -E encoding: Specifies the character encoding scheme to be used in this database
	 
	4 -l locale Specifies the locale to be used in this database.
	5 -T template Specifies the template database from which to build this database.
	6 --help Show help about createdb command line arguments, and exit.
	7 -h host (Specifies the host name of the machine on which the server is running)
	8 -p port (Specifies the TCP port or the local Unix domain socket file extension on which the server is listening for connections)
	9 -U username (User name to connect as)
   10 -w Never issue a password prompt.
   11 -W Force created to prompt for a password before connecting to a database.

	SELECT CURRENT_USER usr, 'HOST' host, inet_server_port() port;

	createdb -h localhost -p 5432 -U postgres testdb
	password******

	postgres# \l

28. pg_basebackup : second partie --------------------------------------**************************************

	postgres
	postgres=# \du
				
				List of roles	
		Role name			Attributes														| Member of
		----------			------------------------------------							-----------
		postgres			|Superuser, Create role, Create DB, Replication, Bypass RLS 	| {}
		replication_user 	|Replication													| {}
		testuser			|Cannot login													| {}
		testuser1			|Create role, Create DB											| {}
		testuser1_local		|																| {}
		testuser2			|																| {}
		
	\l

Prerequisites
--------------
Role Creation to perform the backup.

	postgres=# CREATE USER replication_user WITH REPLICATION ENCRYPTED PASSWORD 'password';

Adding created user in pg_hba.conf file to allow backup

	echo "host replication replication_user 192.168.1.51/32 md5" >> $PGDATA/pg_hba.conf
	view $PGDATA/pg_hba.conf

	#TYPE	DATABASE	USER				ADDRESS				METHOD	  <- ADDRESS specifies the client ip or range of addresses 
	host 	replication replication_user 	192.168.1.51/32 	md5       <- replication here is not a db name but a privilege
	
Get the changes into effect through a reload.

	#sudo su postgres
	$psql -c "select pg_reload_conf()"

To create a base backup of the server at 192.168.1.61 and store it in the local directory /postgres/backup/pgbackup:

	$ pg_basebackup -U replication_user -D /postgres/backup/pgbackup/

To create a backup of the local server with one compressed tar file for each tablespace, and store it in the backup 
directory, showing a progress report while running:

	$ pg_basebackup [-v] -U replication_user -D /postgres/backup/pgbackup/     <- will backup all dir and files in $PGDATA dir in /postgres/backup/pgbackup/
	
	$ pg_basebackup -v  -U replication_user -D /postgres/backup/pgbackup/ -Ft -z -P  <- Ft: format tar , -z: compressed -P: show progress
	Password:
	58133/58133 kB (100%), 1/1 tablespace

	bash-4.2$ pwd
	/postgres/backup/pgbackup
	bash-4.2$ ls -lrt
	total 6940
	-rw---- 1 postgres postgres 7083866 Jun 5 18:03 base.tar.gz
	-rw---- 1 postgres postgres 17091 Jun 5 18:03 pg[wal.tar.gz  <-- Another zip created for the wal 
	
	NB: If you want to backup from a remote server, include : "-h hostname -P port_number"

	To create a backup of a single-tablespace local database and compress it with bzip2:

	$ pg_basebackup -D -Ft -X fetch | bzip2> backup.tar.bz2

	$ pg_basebackup U replication_user -h 192.168.1.51 -D -Ft -X fetch | bzip2 > /postgres/backup/pgbackup/backup.tar.bz2

  (This command will fail if there are multiple tablespaces in the database.)

22.pgbackrest : PostgreSQL backup and restore --------------------------------------------*******************

What is pgBackRest?
------------
pgBackRest is an open source backup tool that creates physical backups with enhancements as compatible with 
the pg_basebackup tool. It can be used to perform an initial database copy for streaming replication by using 
an existing backup, or we can use the delta option to rebuild an old standby server.

Backup Terminology
------------
Full Backup:
	pgBackRest copies the entire contents of the database cluster to the backup.
	The first backup of the database cluster is always a full backup.
	pgBackRest is always able to restore a full backup directly.
	The full backup does not depend on any files outside of the full backup for consistency.

Differential Backup:

	pgBackRest copies only those database cluster files that have changed since the last full backup. 
	The advantage of a differential backup is that it requires less storage than a full backup. 
	To restore a full backup, a diffbkp backup must be valid.

Incremental Backup:

	pgBackRest copies only those database cluster files that have changed since the last backup. 
	The last successful backup can be anyone below:
		Incremental backup
		Differential backup
		Full backup

Enable sudo access to Postgres
------------
	sudo vi /etc/sudoers

	Search for section "NOPASSWD" in the file :

	/NOPASSWD

	Add this line :
	Postgres	ALL=(ALL) NOPASSWD: ALL
	
Disable selinux: by editing file /etc/selinux/config	

****** Start of pgbackrest configuration from here ***

On RHEL/CentOS/OEL:
---------------------
sudo yum install pgbackrest

	Installed products updated.

Installed:
	pgbackrest-2.35-1.rhe18.x86_64

Complete!

[ec2-user@ip-172-31-12-96 ~]$ file /usr/bin/pgbackrest
/usr/bin/pgbackrest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/1d-

Creation of log and repository directory for pgbackrest
------------------------------------------
	sudo su postgres
	file /usr/bin/pgbackrest 

owner will be postgres for repo and log directory;

as EC2 root
---------
	sudo mkdir /var/lib/pgbackrest 
	sudo chown postgres:postgres 
	/var/lib/pgbackrest 
	sudo mkdir -p /var/log/pgbackrest 
	sudo chown postgres:postgres /var/log/pgbackrest

Configuration file for pgbackrest
------------------
What is Stanza in Postgres?
	A stanza defines the backup configuration for a specific PostgreSQL database cluster. 
	Any global configuration sections can be overridden to define stanza-specific settings.

	sudo su postgres sudo 
	mkdir /etc/pgbackrest
	
	sudo bash -c 'cat <<< EOF > /etc/pgbackrest/pgbackrest.conf
	[global]
	repo1-path=/var/lib/pgbackrest
	repo1-retention-full=2				<-- We keep 2 full backups here 

	[Pgems]								<-- Name of the stanza 
	pg1-path=/var/lib/pgsql/13/data
	pg1-port=5432
	EOF'

  cat /etc/pgbackrest/pgbackrest.conf
  
  Note: backup repository location = /var/lib/pgbackrest

Creation of the stanza
------------------
	su postgres
	pgbackrest stanza-create --stanza=Pgems --log-level-console=info

Sample PostgreSQL parameter changes required:
--------------------------------------------

	sudo su Postgres
	psql#

	alter system set wal_level = 'replica';
	alter system set archive_mode = 'on';
	alter system set archive_command = 'pgbackrest --stanza=Pgems archive-push %p';
	alter system set max_wal_senders = '10';
	alter system set hot_standby = 'on';

	show wal_level;
	show archive_mode;
	show archive_command;
	show max_wal_senders;
	show hot_standby;
	
	sudo systemctl restart postgresql-13  

Basic backup configuration post-backup verification:
--------------------------------------------
	sudo su Postgres
	pgbackrest check --stanza=Pgems --log-level-console=info

	sudo systemctl restart postgresql-13
	pgbackrest check --stanza=Pgems --log-level-console=info 

Initiate a Full Backup
------------------------
	pgbackrest backup --stanza=Pgems --log-level-console=info
	
How to verify backup related information
------------------------
	sudo su -postgtres
	pgbackrest info    (see output below:)

	stanza: pg0app
		status: ok
		cipher: none
		
		db (current)
			wal archive min/max (13): 000000010000000000000001/000000010000000000000003
			
			full backup: 20210917-095342F
				timestamp start/stop: 2021-09-17 09:53:42 / 2021-09-17	09:53:48
				wal start/stop: 000000010000000000000003 / 00000010000000000000003

Please note that after a full backup, pgBackRest executes an incremental backup.

	pgBackrest backup --stanza=Pgems --log-level-console=info

[postgres@ip-172-31-10-149 ~]$ pgbackrest info

	stanza: Pgems
		status: ok
		cipher: none

		db (current)
		wal archive min/max (13): 00000001000000000000001/000000010000000000000005
		
		full backup: 20210918-051659F
			timestamp start/stop: 2021-09-18 05:16:59 / 2021-09-18 05:17:03
			wal start/stop: 000000010000000000000003 / 00000010000000000000003
			Database size: 23.3MB, database backup size: 23.3MB
			Repol: Backup set size: 2.8MB, backup size: 2.8MB

		Incr backup: 20210918-051659F_20210918-0519371
			Start/stop timestamp: 2021-09-18 05:19:37 / 2021-09-18 05:19:38
			Start/stop timestamp: 000000010000000000000005 / 000000010000000000000005
			Database size: 23.3MB, database backup size: 8.3KB
			Repol: Backup set size: 2.8MB, backup size: 429B
			Backup reference list: 20210918-051659F

[postgres@ip-172-31-10-149~]$

How to restore backup using pgbackrest
------------------------

	pgBackRest detects

		successful full backup
		differential backup
		incremental backup
		and it does restoration as well.
		
NB: before restoring, postgres should be stopped 

sudo systemctl stop postgresql-13
sudo systemctl status postgresql-13

pgbackrest restore --stanza=Pgems-log-level-console=info
pgbackrest info
pgbackrest restore --stanza=Pgems --log-level-console=info --delta


29.pg_dump and pg_dumpall -------------------------------------------********************************************

	Backup
	 - Pg_dump 		: for backup of individual databases or tables 
	 - Pg_dumpall	: for backup of all databases

	Restore
	 - Pg_restore	: to restore backups not in text format 
	 - psql			: to restore backups in text format

Backup formats 

	1) Plain text (restore psql)
	2) Custom archive (binary format and restore via pg_restore)
	3) Tar archive (binary format and restore via pg_restore)
	4) Directory format (dir format, individual tables and master file with information restored via pg_restore)			
	
2,3 and 4 backup can be done with pg_dump 

pg_dump connection options 
--------------------------

Usage:	pg_dump [OPTION]... [DBNAME]

	-f, --file-FILENAME			output file or directory name
	-F, --format=c|d|t|p		output file format (custom, directory, tar,plain text (default))	
	-i, --jobs=NUM				use this many parallel jobs to dump
	-Z, --compress=0-9 			compression level for compressed formats (9 for highest compression)
	--lock-wait-timeout=TIMEOUT fail after waiting TIMEOUT for a table lock
	--no-sync 					do not wait for changes to be written safely to disk
	-a, --data-only				dump only the data, not the schema
	-b, --blobs					include large objects in dump
	-B, --no-blobs				exclude large objects in dump
	-c, --clean 				clean (drop) database objects before recreating
	-C, --create database		include commands to create in dump
	-E, --encoding=ENCODING		dump the data in
	-n, --schema-PATTERN  		dump the specified schema(s) only
	-N,--exclude-schema=PATTERN do NOT dump the schema(s) specified
	-O, --no-owner 				skip restoration of object ownership in plain-text format
	-s, --schema-only			dump only the schema, no data
	-S, --superuser=NAME		superuser user name to use in plain-text format
	-t, --table-PATTERN 		dump the specified table(s) only
	-T, --exclude-table=PATTERN do NOT dump the specified table(s)
	-x, --no-privileges 		do not dump privileges (grant/revoke)

Connection options:

	-d, --dbname=DBNAME			database to dump
	-h, --host=HOSTNAME 		database server host or socket directory
	-p, --port=PORT				database server port number
	-U, --username=NAME 		connect as specified database user
	-w, --no-password			never prompt for password
	-W, --password   			force password prompt (should happen automatically)
	--role=ROLENAME				do SET ROLE before dump

pg_restore:
---------
pg_restore restores a PostgreSQL database from an archive created by pg_dump.

Usage: pg_restore [OPTION]... [FILE]

General options:

	-d, --dbname=NAME		connect to database name
	-f, --file-FILENAME		output file name (- for stdout)
	-F, --format-c|d|t		backup file format (should be automatic)
	-l, --list				print summarized TOC of the archive
	-v, --verbose			verbose mode

Options controlling the restore:

	-a, --data-only			restore only the data, no schema
	-c, --clean 			clean (drop) database objects before recreating
	-C, --create			create the target database
	-e, --exit-on-error 	exit on error, default is to continue
	-l, --index=NAME		restore named index
	-j, --jobs=NUM 			use this many parallel jobs to restore
	-L, --use-list-FILENAME use table of contents from this file for selecting/ordering output


