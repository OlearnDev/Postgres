----- PostegreSQL -----------

https://www.youtube.com/watch?v=Tn67kCaLElk&list=PLwxrtuGg5dNGv4jvDY3TEddn2HIn4-uF9&index=2

1.Intro and Architecture -----------------------------

FEATURES OF POSTGRES

	Multi-Version Concurrency Control (MVCC) architecture.
	Granular access controls
	Tablespaces
	Asynchronous replication
	Online/hot backups, write-ahead logging.
	Supports international character sets
	Highly scalable both in the quantity of data
	PostgreSQL''s write-ahead logging makes it a highly fault-tolerant database
	
- Open source 

*** Memory and process 

(See arch in word file)

Data Flow :

	- Application connects to the postmaster process.
	- The postmaster checks the application''s rights and, if successful, starts a new Postgres process and connects 
	  it with the client application.
	- The instance doesn''t write or read the requested data directly to or from disk files. Instead, it buffers them 
	  in a shared memory area called the shared buffers.
	- The Postgres process acts on the shared buffers and WAL buffers and manipulates their contents.
	- The client requests a Commit, and the WAL writer process writes and flushes all WAL records resulting from this
	  transaction to the WAL file. As the WAL file, in contrast to the data files, is written strictly sequentially,
	- Periodically, the background writer process checks the shared buffers for 'dirty' pages and writes them to the 
	  appropriate data files.
	- In essence, the instance contains at least three processes: WAL writer, background writer, and checkpointer, and 
	  one Postgres process per connection. In most cases, there are a few more processes running

Background Processes :

Process				Description
-------------		--------------------------------------------
Logger				Write the error message to the log file.
Checkpointer		When a checkpoint occurs, the dirty buffer is written to the file.
Writer				Periodically writes the dirty buffer to a file.
WAL Writer			Write the WAL buffer to the WAL file.
Autovacuum Launcher	Fork autovacuum worker when autovacuum is enabled.lt. It is the responsibility of the autovacuum 
					daemon to carry out vacuum operations on bloated tables on demand.
Archiver			When in Archive.log mode, copy the WAL file to the specified directory.
Stats Collector		DBMS usage statistics such as session execution information (pg_stat_activity) and table usage 
					statistical information (pg_stat_all_tables) are collected
					

Memory :

Memory TYPE			Description 
---------------		-------------------------------------------------		
Shared Memory		(database caching and transaction log caching)

Shared Buffer		- Minimizes DISK IO
					- Access very large (tens, hundreds of gigabytes) buffers quickly
					- Minimizes contention when many users access it at the same time
					- Frequently used blocks must be in the buffer for as long as possible

WAL Buffer 			- Temporarily stores changes to the database
					- Written to the WAL file
					- Useful for backup and recovery

Postmaster Process	- The Postmaster process is the first process started when you start PostgreSQL
					- At startup, performs recovery,
					- Initialize shared memory
					- Run background processes
					- It also creates a backend process when there is a connection request from the client process				
					
work_mem Space		 - Used for sorting, bitmap operations, hash joins, and merge joins. The default setting is 4 MB.
Maintenance_work_mem - Space used for Vacuum and Create Index. The default setting is 64 MB.
Temp_buffers		 - Space used for temporary tables. The default setting is 8 MB				


3.Installation of postgresql ------------------------------------------------------------------

Installation Directory: C:\Program Files\PostgreSQL\17
Server Installation Directory: C:\Program Files\PostgreSQL\17
Data Directory: C:\Program Files\PostgreSQL\17\data
Database Port: 5432
Database Superuser: postgres
Operating System Account: NT AUTHORITY\NetworkService
Database Service: postgresql-x64-17
Command Line Tools Installation Directory: C:\Program Files\PostgreSQL\17
pgAdmin4 Installation Directory: C:\Program Files\PostgreSQL\17\pgAdmin 4
Stack Builder Installation Directory: C:\Program Files\PostgreSQL\17
Installation Log: C:\Users\oline\AppData\Local\Temp\install-postgresql.log

user postgres/postgres



------------- Step 1 : Installing PostgreSQL on Linux 7.5

You can see installation steps on postgresql site : https://www.postgresql.org/download/linux/redhat/

Summary below :

	yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86-64/pgdg-redhat-repo-latest.noarch.rpm  --repo
	yum install postgresql12			-- client
	yum install postgresql12-server		-- server

	/usr/pgsql-12/bin/postgresql-12-setup initdb	-- Initialize the db
	systemctl enable postgresql-12					-- Allow postgresql start when system restarts
	systemctl start postgresql-12
	systemctl status postgresql-12

------------- Step 2 :  USING POSTGRESQL ROLE

The installation procedure created a user account called postgres that is associated with the default Postgres role
and a a sudo user.

SWITCH to POSTGRES ACCOUNT
#sudo -u postgres

You can now access a Postgres prompt by typing below command:

$psql
postgres# \du 	: displays all roles/users available  -- there is a role colled "postegres" which is superuser

postgres# \q	: to exit psql

------------- Step 3 : CREATING A NEW NON DEFAULT ROLE.

You have the postgres role configured within the database.
You can create new roles from the command line with the createrole command. 
The "--interactive" flag will prompt you for the name of the new role and also ask whether it should have superuser 
permissions.

If you are logged in as the postgres account. 

-bash-4.2$ createuser-interactive
Enter name of role to add: testuser
Shall the new role be a superuser? (y/n) n
Shall the new role be allowed to create databases? (y/n) n
Shall the new role be allowed to create more new roles? (y/n) n

-bash-4.2$

$sudo -i -u postgres 

connect to 


4.MANAGING TABLESPACES ------------------------------------------

pg_default :tablespace stores all user data.
pg_global : tablespace stores all global data (dictionnaire)

---------- DEFAULT STORAGE IN POSTGTRESQL

pg_ctl -D data initdb
Is -IF data
pg_ctl -D data start

When you initialize postgre, the Postgres server creates the required files in $PGDATA directory 

The Default Tablespaces

Two tablespaces are automatically created when the database cluster is initialized.

pg_global  : tablespace is used for shared system catalogs.
pg_default : tablespace is the default tablespace for users and also for templatel and template0 databases

--- Creating a new tbs

postgres# create tablespace tbs1 location '/postgres/data/tbs1';
postgres# \db+
Is -l data/pg_tblspc/

Creating Objects :

create database dbl tablespace tbs1;
\c dbl					-- Switch to db : db1

create table tabl (a int);
create table tab2 (a int) tablespace tbs2;
create table tab3 (a int) tablespace pg_default;

---- Demo 

Initialize an instance :  1

$ sudo su - postgres
$ mkdir -p /postgres/data/instancel
$ pg_ctl -D /postgres/data/instancel initdb  *

Start the database server using : 2

$ pg_ctl -D /postgres/data/instancel start
or 
$ pg_ctl -D /postgres/data/instancel -l logfile start  *

$ pg_ctl -D data initdb
Is -lF data
pg_ctl -D data start

 \db+
    Name    |  Owner   |          Location           | Access privileges | Options |  Size   | Description
------------+----------+-----------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                             |                   |         | 22 MB   |
 pg_global  | postgres |                             |                   |         | 565 kB  |
 
postgres@OlivierLP:~/16/data$ pwd
/var/lib/postgresql/16/data
postgres@OlivierLP:~/16/data$ psql
psql (16.4 (Ubuntu 16.4-0ubuntu0.24.04.2))
Type "help" for help.

postgres=# create tablespace tbs1 location '/var/lib/postgresql/16/data';
CREATE TABLESPACE

postgres=# \db+		: see all tbs
                                            List of tablespaces
    Name    |  Owner   |          Location           | Access privileges | Options |  Size   | Description
------------+----------+-----------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                             |                   |         | 22 MB   |
 pg_global  | postgres |                             |                   |         | 565 kB  |
 tbs1       | postgres | /var/lib/postgresql/16/data |                   |         | 0 bytes |
(3 rows)

postgres=# exit
postgres@OlivierLP:~/16/data$ ls -ltrh
total 4.0K
drwx------ 2 postgres postgres 4.0K Nov  8 22:33 PG_16_202307071
postgres@OlivierLP:~/16/data$

***** pg_tblspc : folder in $PGDATA where you have symbolic links to tablespaces folders associated with tablespaces 

postgres@OlivierLP:~/16/main$ ls
PG_VERSION  pg_commit_ts  pg_multixact  pg_serial     pg_stat_tmp  pg_twophase  postgresql.auto.conf
base        pg_dynshmem   pg_notify     pg_snapshots  pg_subtrans  pg_wal       postmaster.opts
global      pg_logical    pg_replslot   pg_stat       pg_tblspc    pg_xact      postmaster.pid
postgres@OlivierLP:~/16/main$ cd pg_tblspc
postgres@OlivierLP:~/16/main/pg_tblspc$
postgres@OlivierLP:~/16/main/pg_tblspc$ ls -ltrh
total 0
lrwxrwxrwx 1 postgres postgres 27 Nov  8 22:33 16390 -> /var/lib/postgresql/16/data

NB : l''id pour le nouveau tbs est : 16390


***** Create database with default tbs :

postgres=# create database db1 tablespace tbs1;
postgres=# \l
                                                   List of databases
   Name    |  Owner   | Encoding | Locale Provider | Collate |  Ctype  | ICU Locale | ICU Rules |   Access privileges
-----------+----------+----------+-----------------+---------+---------+------------+-----------+-----------------------
 db1       | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           |
 postgres  | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           |
 template0 | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           | =c/postgres          +
           |          |          |                 |         |         |            |           | postgres=CTc/postgres
 template1 | postgres | UTF8     | libc            | C.UTF-8 | C.UTF-8 |            |           | =c/postgres          +
           |          |          |                 |         |         |            |           | postgres=CTc/postgres
(4 rows)

postgres@OlivierLP:~/16/main/pg_tblspc$ mkdir -p /var/lib/postgresql/16/data/tbs2
postgres=# create tablespace tbs2 location '/var/lib/postgresql/16/data/tbs2';
CREATE TABLESPACE


postgres=#

***** switch to db1 and create tables 

postgres=# \c db1
You are now connected to database "db1" as user "postgres".

db1=# create table tabl (a int);
CREATE TABLE
db1=#

postgres=# \db+
                                              List of tablespaces
    Name    |  Owner   |             Location             | Access privileges | Options |  Size   | Description
------------+----------+----------------------------------+-------------------+---------+---------+-------------
 pg_default | postgres |                                  |                   |         | 22 MB   |
 pg_global  | postgres |                                  |                   |         | 565 kB  |
 tbs1       | postgres | /var/lib/postgresql/16/data      |                   |         | 7568 kB |
 tbs2       | postgres | /var/lib/postgresql/16/data/tbs2 |                   |         | 0 bytes |
(4 rows)

postgres=# create table tab2 (a int) tablespace tbs2;
CREATE TABLE
postgres=# create table tab3 (a int) tablespace pg_default;
CREATE TABLE
postgres=# \db+
                                                List of tablespaces
    Name    |  Owner   |             Location             | Access privileges | Options |    Size    | Description
------------+----------+----------------------------------+-------------------+---------+------------+-------------
 pg_default | postgres |                                  |                   |         | 22 MB      |
 pg_global  | postgres |                                  |                   |         | 565 kB     |
 tbs1       | postgres | /var/lib/postgresql/16/data      |                   |         | 7568 kB    |
 tbs2       | postgres | /var/lib/postgresql/16/data/tbs2 |                   |         | 4096 bytes |
(4 rows)

postgres=#

***** ******** How to move objects from one tablespace to another

NB: There will be a lock on the table while moving to another tbs

alter table tabl set tablespace pg_default;
alter table all in tablespace tbs1 set tablespace pg_default;

*********** Tablespace Properties

alter tablespace space2 set (seq_page_cost=0.5, random_page_cost=0.5);   -- No tested : Need to check further

*********** Set default tablespace for users

postgres=# SET default_tablespace = tbs2;
SET
postgres=# show default_tablespace ;
 default_tablespace
--------------------
 tbs2
(1 row)

postgres=# create table foo (i int);
CREATE TABLE
postgres=# select * from pg_tables where tablename='foo';
 schemaname | tablename | tableowner | tablespace | hasindexes | hasrules | hastriggers | rowsecurity
------------+-----------+------------+------------+------------+----------+-------------+-------------
 public     | foo       | postgres   | tbs2       | f          | f        | f           | f
(1 row)

postgres=# select relname,reltablespace from pg_class where reltablespace in(select
oid from pg_tablespace where spcname not in ('pg_default','pg_global'));
 relname | reltablespace
---------+---------------
 tab2    |         16397
 foo     |         16397
 tab1    |         16390
(3 rows)

postgres=# select * from pg_tablespace;
  oid  |  spcname   | spcowner | spcacl | spcoptions
-------+------------+----------+--------+------------
  1663 | pg_default |       10 |        |
  1664 | pg_global  |       10 |        |
 16390 | tbs1       |       10 |        |
 16397 | tbs2       |       10 |        |
(4 rows)

postgres=# select  relname,reltablespace from pg_class where relname like 'tab%';

      relname      | reltablespace
-------------------+---------------
 tab1              |         16390
 tab2              |         16397
 tab3              |             0
 table_constraints |             0
 table_privileges  |             0
 tables            |             0
(6 rows)

***********  How to Backup additional tablespace

pg_basebackup --format=p --tablespace-mapping=/tmp/space2=/tmp/space2backup -D plainb

*********** Why is tablespace is used for

- Database growing then create a new tablespace and move objects from existing to new tablespace. 
- High perfomrming disk move indexes and table to that

5.How to change data directory --------------------------------------------------

postgres=# show data_directory;
       data_directory
-----------------------------
 /var/lib/postgresql/16/main
(1 row)

postgres=#  

New datadir location: /postgres/data

***********  STEP 2 - SHUTDOWN POSTGRES SERVICE.
Depending on postgresql installed :

sudo systemctl status postgresql-12    
sudo systemctl stop postgresql-12 
sudo systemctl status postgresql-12

or 

If postgre user already in sudoers, no need to add sudo at the beginning :

$ service postgresql status
$ service postgresql stop
$ service postgresql status

***********  STEP 3 Copy/move data from current data directory to new location.

#chown postgres: postgres /postgres/data 
$chmod -R 750 /postgres/data

cd /var/lib/pgsql/12/data/ 
cp -r * /postgres/data 
cd /postgres/data
ls -lrt

***********  Step 4 Update New Data dir Location in config file. ***

cp /var/lib/pgsql/12/data/postgresql.conf /var/lib/pgsql/12/data/postgresql.conf_orig

sudo vi /var/lib/pgsql/12/data/postgresql.conf

data_directory = '/postgres/data/'

***********  Step 5 Restarting Postgres ***********  

sudo systemctl start postgresql-12
sudo systemctl status postgresql-12

or 

$ service postgresql stop
$ service postgresql status

tail -10f /var/log/messages

***********  Step 6 Verify new location ***

sudo u postgres psql 
SHOW data_directory;

postgres=# SHOW data_directory; 
data_directory
/postgres/data (1 row)


6.Introduction to PostgreSQL log_statement ----------****************************************************

- It''s related to error and error reporting, along with warnings and database queries in a logfile.
- The default log_statement option in the PostgreSQL configuration file is none, which means nothing will be logged 
  into the error file.

	Options:
		NONE
		DDL 
		MOD
		ALL

How does log_statement work in PostgreSQL?

- It''s a useful parameter in PostgreSQL used to log errors in the logfile, database warning messages, and SQL queries.
- Log_statements have four options available in PostgreSQL, as mentioned below.

None:
	- This option of log_statement is defined as not logging any query in the error log file.
	- This is the default configuration option of log_statement available. This is also defined as turning off the 
	  log_statement parameter for PostgreSQL.
DDL: 
	- Log all queries that are under the category of the DDL statement.
		E.g., create, alter, and drop statements.
A11:
	- This option is defined as logging all statements executed by the user
	- It is logging DDL, DML, and all the query language in PostgreSQL.
	- Not advised

Mod:
	- This option in log_statement is defined as log DDL query as well as log the modifying statement like delete, 
	  update, truncate, insert, copy, execute, and prepare

Example #1  Log statement with none options.**************************

It will not log anything into the error log.

psql script:

show log statement;

create table course (course_no integer, name text, price numeric); 
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, "mysql", 160),
	(3, 'mongodb', 170);

select from course;

tail -10f postgresql-***.log

Example #2  Log statement using DOL options. **************************

In the following example, we have used DDL options with the log statement parameter. It will log only the DDL 
statement into the error log.

Psql script:

alter system, set log statement 'DDL';

$sudo systemctl restart postgresql-12 

$psql
postgres# show log statement;

	log_statement
	--------
	ddl
	(1 row)

CREATE TABLE course (course_no integer,name, text,price, numeric);
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, 'mysql', 160),
	(3, 'mongodb', 170);

postgres# select from course;

course_no	name		price

1			postgres	150
2			mysql		160
3			mongodb		170
(3 rows)

delete from course;

Example #3 Log statement using ALL options. **************************

In the example below, we have used ALL options with the log statement parameter. It will log all statements 
into the error log.

Psql script:

alter system set log statement "ALL";

show log statement;

CREATE TABLE course (course_no integer,name text,price numeric);
select * from course;

Example #4  Log statement using mod options.  **************************

In the following example, we have used mod options with the log statement parameter. It will log DDL and DML 
into the error log.

Psql script:

alter system set log statement 'mod';
$sudo systemctl restart postgresql-12 

$psql
postgres# show log statement;

explain select * from courses;
INSERT INTO course (course_no, name, price) VALUES
	(1, 'postgres', 150),
	(2, "mysql", 160),
	(3, 'mongodb', 170);

tail -10f postgresql-Mon.log

8.Repmgr (Replication & Failover Management) **************************

**** Streaming Replication in PostgreSQL (2 EC2 PostgreSQL-13)******

Postgres replication is the process of copying data from one database host (primary) to another database host 
(standby).

In version 9.0 (back in 2010), streaming replication was introduced.

- Streaming replication in PostgreSQL works on log shipping.
- Every transaction in PostgreSQL is written to a transaction log called WAL (write-ahead log) to achieve 
  durability.
- A slave uses these WAL segments to continuously replicate changes from its master.

In streaming replication, three kinds of processes work cooperatively.
	- A WAL sender process on the primary server sends WAL data to the standby server;
	- and then, a WAL receiver and a startup process on the standby server receives and replays this data.
	- A WAL sender and a WAL receiver communicate using a single TCP connection.

PostgreSQL is a widely used relational database that supports both logical and physical replication:

- Logical replication streams high-level changes from the primary database cluster to the replica databases.
  Using logical replication, you can stream changes to just a single database or table in a database.

- In physical replication, changes to the WAL (Write-Ahead-Logging) log file are streamed and replicated in the 
 replica clusters. As a result, you can''t replicate specific areas of a primary database cluster; instead, all 
 changes to the primary are replicated


Overview of REPMGR ****************************

repmgr is an open-source tool for managing replication and failover of PostgreSQL servers.
It supports and enhances PostgreSQL''s built-in streaming replication which provides a single read/write 
primary server and one or more read-only standbys containing near-real-time copies of the primary server''s 
database.

It provides two main tools:

	1) repmgr:

		A command-line tool used to perform administrative tasks such as:

		Setting up standby servers.
		Promoting a standby server to primary.
		Switching between primary and standby servers.
		Displaying the status of servers in the replication cluster.

	2) repmgrd:

		A daemon that actively monitors servers in a replication cluster and performs below:
		 - Monitoring and recording replication performance
		 - Performing failover by detecting failure of the primary and promoting the most suitable standby server

Repmgr User and Metadata

Repmgr needs to store information about the servers in the cluster in a schema.
This schema is automatically created by the Repmgr extension which is installed during the first step in 
initializing a Repmgr-administered cluster (Repmgr primary register) and contains the following objects:

Tables :

	Repmgr.events: Records events of interest
	Repmgr.nodes: Connection and status information for all hosts of the cluster.
	Repmgr.monitoring_history: Historical standby monitoring information.

Views :

  Repmgr.show_nodes: Based on the Repmgr.nodes table, additionally showing name of the server''s upstream node.
  Repmgr.replication_status: When Repmgr''s monitoring is enabled, shows current monitoring status for each stan...
  The Repmgr metadata schema can be stored in an existing database or in its own dedicated database. Note that 
     the Repmgr metadata schema cannot reside on a database server that is not part of the replication c... 
	 managed by Repmgr

A database user must be available to access this database and make necessary changes
This user does not need to be a superuser, however some operations such as the initial installation of the 
  repmgr extension will require a superuser connection (this can be specified where required with the co...

Installation of REPMGR
-----------
  repmgr can be installed from binary packages provided by your OS packaging system, or from source.

Requirements for installing repmgr
-----------
	All cluster servers have the same major version of PostgreSQL, same minor version.

	repmgr must be installed on each server in the replication cluster.
	If installing repmgr from packages, the package version must match the PostgreSQL version.
	If installing from source, repmgr must be compiled against the same major version.

Installing repmgr from packages
-----------
repmgr RPM packages for RedHat/CentOS variants and Fedora are available from the 2ndQuadrant public repository;

sudo yum install repmgri1

Prerequisites for setting up a basic replication cluster with repmgr
-----------
We''ll assume the
	primary is called node with IP address 192.168.1.51
	standby is called node2 with IP address 192.168.1.61

	Following software must be installed on both servers:
		PostgreSQL
		repmgr (matching the installed PostgreSQL major version)

At the network level
-----------
	- Connections between the PostgreSQL port (default: 5432) must be possible in both directions.
	- If you want repmgr to copy configuration files which are located outside the PostgreSQL data directory,
	    and/or to test switchover functionality,you need passwordless SSH connections between both servers, 
	    and rsync should be installed

PostgreSQL Configuration
-----------
On the primary server, a PostgreSQL instance must be initialized and running.
The following replication settings may need to be adjusted:

# Enable replication connections; set this value to at least one more than the number of standbys that will connect 
# to this server. (Note that repmgr will execute "pg_basebackup" in WAL streaming mode which requires two free 
# WAL senders).

max_wal_senders = 10

# If using replication slots, set this value to at least one more than the number of standbys that will connect to 
# this server. Note that repmgr will only make use of replication slots if "use_replication_slots" is set to "true" in
# "repmgr.conf". (If you are not intending to use replication slots, this value can be set to "0").

max_replication_slots = 10  -- used in our case

# Ensure WAL files contain enough information to enable read-only queries on the standby.
# PostgreSQL 9.5 and earlier: one of 'hot_standby' or 'logical'
# PostgreSQL 9.6 and later: one of 'replica' or 'logical'
# ('hot_standby' will still be accepted as an alias for 'replica')

wal_level = 'hot_standby'

# Enable read-only queries on a standby
# (Note: this will be ignored on a primary, but we recommend including it anyway, in case the primary later becomes 
# a standby)

hot_standby = on

# Enable WAL file archiving

archive_mode = on

# Set archive command to a dummy command; this can later be changed without needing to restart the PostgreSQL instance.

archive_command = '/bin/true'

Create the repmgr user and database
----------------------
createuser -s repmgr
createdb repmgr -0 repmgr
ALTER USER repmgr SET search_path TO repmgr, "$user", public;

Configuring authentication in pg_hba.conf
--------------------------------------------
Ensure the repmgr user has appropriate permissions in pg_hba.conf and can connect in replication mode;
pg_hba.conf should contain entries similar to the following:  [6 lines important for replication]

	local	replication	repmgr					trust
	host	replication	repmgr	127.0.0.1/32	trust
	host	replication	repmgr	192.168.1.0/24	trust

	local	repmgr		repmgr					trust
	host	repmgr		repmgr	127.0.0.1/32	trust
	host	repmgr		repmgr	192.168.1.0/24	trust

Preparing the standby
----------------
	- Do not create a PostgreSQL instance (i.e., do not execute initdb), but do ensure the destination data directory 
	  (and any other directories you want PostgreSQL to use) exist and are owned by the Postgres system user.
	- Permissions must be set to 0700 (drwx------).
	- Check the primary database is reachable from the standby using psql:

	  psql 'host=node1 user=repmgr dbname=repmgr connect_timeout=2'

repmgr configuration file Primary
----------------
  Create a repmgr.conf file on the primary server. The file must contain at least the following parameters:

	node_id=1
	node_name='node1'
	conninfo='host=node1 user=repmgr dbname=repmgr connect_timeout=2'
	data_directory='/var/lib/postgresql/data'

  repmgr.conf should not be stored inside the PostgreSQL data directory, as it could be overwritten when setting up
  or reinitializing the PostgreSQL server.

Register the primary server
----------------
To enable repmgr to support a replication cluster, the primary node must be registered with repmgr. This installs the 
repmgr extension and metadata objects, and adds a metadata record for the primary server:

	$ repmgr -f /etc/repmgr.conf primary register   --repmgr.conf has the 4 params above

	INFO: connecting to primary database..
	NOTICE: attempting to install extension "repmgr"
	NOTICE: "repmgr" extension successfully installed
	NOTICE: primary node record (id: 1) registered

Verify the status of the cluster like this:

$ repmgr -f /etc/repmgr.conf cluster show

ID	Name	Role 	|Status 	|Upstream |Connection string
-------------------------------------------
1	node1	primary |* running |		  | host node1 dbname=repmgr user repmgr connect_timeout=2

The record in the repmgr metadata table will look like this:

	repmgr=# SELECT * FROM repmgr.nodes;
	
	-[ RECORD 1]---+--------------
	node_id				1
	upstream_node_id	
	active				t
	node_name			node1
	type				primary
	location			default
	priority			100
	conninfo			host node1 dbname=repmgr user repmgr connect_timeout=2
	replzer				repmgr
	slot_name
	config_file			/etc/repmgr.conf

Each server in the replication cluster will have its own record.
If repmgrd is in use, the fields upstream_node_id, active, and type will be updated when the node''s status or role 
  changes.

Clone the standby server
-----------------
Create a repmgr.conf file on the standby server. It must contain at least the same parameters as the primary''s 
repmgr.conf, but with the mandatory values node, node_name, conninfo (and possibly data_directory) adjusted 
accordingly, e.g.:

	node_id=2
	node_name='node2'
	conninfo='host=node2 user=repmgr dbname=repmgr connect_timeout=2'
	data_directory='/var/lib/postgresql/data'

Use the -dry-run option to check the standby can be cloned:

	$ repmgr -h node1 U repmgr -d repmgr -f /etc/repmgr.conf standby clone --dry-run

	NOTICE: using the provided configuration file "/etc/repmgr.conf"
	NOTICE: destination directory "/var/lib/postgresql/data" provided
	INFO: connecting to source node
	NOTICE: Checking for available walsenders on source node (2 required)
	INFO: Sufficient walsenders available on source node (2 required)
	NOTICE: Standby will attach to upstream node 1
	HINT: Consider using the -c/--fast-checkpoint option
	INFO: All prerequisites for "standby clone" are met

	$ repmgr -h node1 U repmgr -d repmgr -f /etc/repmgr.conf standby clone  //run effectiveliy

This has cloned the PostgreSQL data directory files from the primary node 1 using PostgreSQL''s pg_basebackup utility.
A recovery.conf file containing the correct parameters to start streaming from this primary server will be created 
automatically.

Note
------
By default, any config files in the primary''s data directory will be copied to the standby.Typically, these will be

	postgresql.conf,
	postgresql.auto.conf,
	pg_hba.conf, and
	pg_ident.conf.

These may require modification before the standby is started.
Make any adjustments to the standby''s PostgreSQL configuration files now, then start the server	
	
Verify replication is functioning
------------------------------------
Connect to the primary server and execute:

	repmgr=# SELECT * FROM pg_stat_replication;

This shows that the previously cloned standby (node2 shown in the application_name field) has connected to the primary
from its IP address...

From PostgreSQL 9.6, you can also use the pg_stat_wal_receiver view to check the replication status from the standby.

	repmgr=# SELECT * FROM pg_stat_wal_receiver;

Note that the conninfo value is generated in recovery.conf and will differ slightly from the primary''s conninfo as 
set in repmgr.

Register the standby
--------------
Register the standby server with:

	$ repmgr -f /etc/repmgr.conf standby register

	NOTICE: standby node "node2" (ID: 2) successfully registered

Check the node is registered by executing repmgr cluster show on the standby:

	$ repmgr -f /etc/repmgr.conf cluster show

	ID 	|Name 	|Role 	|Status |Upstream |Location |Priority |Timeline |Connection string
	-----------------------------------------------------------------
	1 	node1	primary	 running |		  |default	 100		1		| host=node1 dbname=repmgr user=repmgr
	2 	node2	standby |running  node1	  | default |100		1		| host=node2 dbname=repmgr user=repmgr

Both nodes are now registered with repmgr and the records have been copied to the standby server.

Demo pending ...coming ASAP

9.PSQL CHEATSHEET.  [Usual commands]-------------------------------------------------------------------------------

How to Connect to psql Locally on Linux

1# sudo u postgres psql
or
2. # sudo su postgres

	2a. $ psql U postgres -p 5432 -W    <- Option -W prompts for the password
	2b. $ psql U postgres -p 5432 -w	<- Option -w to login without password
	2c. $ psql

3. How to connect psql remotely from the command line.

Note: psql is built as a "console application." Since the Windows console, windows use a different encoding than the rest of the system.

chcp 1252

cd C:\Program Files\PostgreSQL\12\bin
psql -U postgres p 5432 h 192.168.1.61 -W	<- To connect remotely 
  password

4. \d

5.	\1: List databases
	\c dbname "Connect to a database"
	psql -h 192.168.1.61 p 5432 U postgres dvdrental

6. Tables related commands
	\dt						: list of tables of connected db
	\c dvdrental
	\dt
	\d tablename  : Show table definition (columns, etc.) including triggers
	\d+ tablename : More detailed table definition including description and physical disk size.
	\dt *.*

postgres # select * from pg_catalog.pg_tables where schemaname != 'pg_catalog' and schemaname != 'information_schema';

7.  \di 	 :List indexes
	\d actor : Lists indexes of a particular table 

postgres # SELECT tablename, indexname, indexdef from pg_indexes WHERE tablename LIKE '%actor%' ORDER BY tablename, indexname;

8. \dn: List schemas
	CREATE SCHEMA myschema;
	DROP SCHEMA myschema;
	DROP SCHEMA myschema CASCADE;
	
9.	\dy: List events
	\df: List functions
	\df+ <function_name> Show function SQL code.
	\dT+: List all data types
	\dv: List views
	\dx: List all extensions installed
	\x: Pretty-format query results instead of the not-so-useful ASCII tables
	\copy (SELECT FROM_table_name) TO 'file_path_and_name.csv' WITH CSV: Export a table as CSV
	\copy (SELECT * FROM actor) TO 'c:\actor.csv' WITH CSV: Export a table as CSV
	\des+: List all foreign servers
	\dE[S+]: List all foreign tables

10.	\du: List users
	\du appreporting_user1: List a username if present.

	set role appreporting_user1; Change the role for the current session to testuser.

	\deu+: List all user mappings on the server

10.Postgresql on Docker -------------------------------------------------------------------------------

HOW TO INSTALL POSTGRESQL ON DOCKER

Uninstall Old Versions of Docker:
	sudo apt-get remove docker docker-engine docker.io

Docker installation on Ubuntu: 
	sudo apt-get update

How to install Docker on Ubuntu: sudo apt install docker.io

Start and automate Docker on host reboot

	sudo systemctl start docker
	sudo systemctl enable docker
	sudo systemctl status docker

How to check docker version
	docker --version

Step to pull Postgres image and the container. Let''s pull postgres image onto Ubuntu system from docker hub.
	sudo docker pull postgres

How to verify all existing Docker images.
	sudo docker images

Once verified, start the Postgres instance.

	sudo docker run -name postgres-docker_3e POSTGRES_PASSWORD=password -p 5433:5433 -d postgres
	sudo docker run -name postgres-docker_2e POSTGRES_PASSWORD=password p 5434:5434 d postgres

Check Docker for the containers that are running.

	sudo docker ps

Connect with the Docker Postgres container and connect to the psql command.

	sudo docker exec -it postgres-0 psql -U postgres
	sudo docker exec -it postgres-docker_2 psql -U postgres

--- additional commands 

Check Docker version.
	sudo docker-version

How to download Docker image.
	sudo docker pull image_name

How to list down all existing images installed.
	sudo docker images

How to run Docker image:
	sudo docker run itd image_name

How to check which container is running in Docker.
	sudo docker ps

To list all Dockers with status and with the container info.
	sudo docker ps -a

How to access Docker container:
	sudo docker exec it container_id bash

How to remove a Docker container.
	sudo docker rm container_id

To remove a particular image.
	sudo docker rmi image_id

How to restart a Docker container.
	sudo docker restart container_id

How to stop a Docker container.
	sudo docker stop container_id


12.PostgreSQL internat authentication -------------------------------------------------------------------------------

PostgreSQL manages internal authentication mechanisms as mentioned in the pg_hba.conf file

cat pg_hba.conf|grep i method

	# METHOD can be "trust", "reject", "md5", "password", "scram-sha-256",
	# Authentication methods refer to the "Client Authentication"

	Note: This is an inter-process communication mechanism that allows bidirectional data exchange between processes 
	running on the ...

	Column of all pg_hba.conf
	--------------------

	# TYPE		DATABASE		USER		ADDRESS		METHOD
	# "local" is for Unix domain socket connections only
	local		all				all						 peer

	# IPv4 local connections:
	host		all				all			127.0.0.1/32 ident

	# IPv6 local connections:
	host		all				all			::1/128		 ident

Column 1:Local is used by Unix-Domain socket. If it is a host, mention the host IP address in the address column.
Column 2: Used for the database; mention the database name.
   If it has been set to all, then all the databases in the PostgreSQL cluster will use the same auth mechanism.
Column 3: It is the user. It can be set to separate auth methods for different users, and "all" means for all users.
Column 4: IP address. For example, the IP address can use a particular authentication method.
Column 5: Which auth mode of authentication has to be used

NB: Different Methods :***********

-bash-4.2$ cat $PGDATA/pg_hba.conf|grep i method

local		DATABASE 	USER 	METHOD 		[OPTIONS]
host 		DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostssl 	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostnossl	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostgssenc	DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS]
hostnogssenc DATABASE 	USER 	ADDRESS 	METHOD [OPTIONS] 

Method can be "trust", "reject", "md5", "password", "scram-sha-256", authentication methods -- refer to the 
"Client Authentication"
********************************

Auth method Trust
--------------------
A user mentioned with trust does not require any password for authentication.

Example-1

# TYPE	DATABASE	USER	ADDRESS			METHOD

host	all			all		127.0.0.1/32	trust   <- Any conn from localhost will go through trust auth method and will be accepted

Example-2

# TYPE	DATABASE	USER	ADDRESS			METHOD

host	all			all		127.0.0.1/32	reject <- Any host that is not localhost will have the connection rejected.

Testing
	Trust Authentication
	--------------------
		Login From localhost
			postgres@127.0.01:~$ psql postgres -h 127.0.0.1 -U postgres

	Reject Authentication
	--------------------
	Login From Remote Host
		postgres@IP~$ psql postgres -h IP U postgres
		psql: error: could not connect to server:
		FATAL: pg_hba.conf rejects connection for host "IP", user "postgres", database "postgres"

md5 Authentication
--------------------
When using md5 authentication, you must provide the password.

Example

host	database	user 	address			auth-method
host	all			all		127.0.0.1/32	md5

testing
	psql postgres -h IP -U postgres

SCRAM Authentication
--------------------
It is one of the most secure authentication methods, using cryptographically hashed security mechanisms to store 
passwords on the system.

testing
	SET password encryption = 'scram-sha-256';
	
	ALTER USER postgres WITH PASSWORD 'password';

Modify hab.conf as below

host 	database 	user 	address		auth-method
host	all			all		IP/32		<span class="s1">scram-sha-256</span>

psql postgres -U postgres

13.Backup and Restore using pg_basebackup ------------------------------------------------------------------------

How to backup and restore using pb_basebackup on the same host

Step-by-step backup and restoration using pb_basebackup

Prerequisites
-----------------
EC2 RHEL instance ready with access
Sample database dvdrental loaded.

psql

postgres# show data_directory

	 data directory
	---------------------------------
	/var/lib/pgsql/13/data 
	(1 row)

postgres#\db+
		List of tablespaces

	Name		Owner	Location	Access privileges 	Options Size		Description 
	------		-----	----------	-----------------	-----	---------	------------------
	pg_default	postgres										1879 MB
	pg_global	postgres										1583 kB

	(2 rows)

\l+

dvdrental_99+=# show config_file;

	config file
	-------------------------------------
	/var/lib/pgsql/13/data/postgresql.conf

	(1 row)

vi /var/lib/pgsql/13/data/postgresql.conf

archive_mode=on
archive timeout=300
archive_command='archive_command | test ! -f /var/lib/pgsql/13/data/pg_wal/%f && cp %p /var/lib/pgsql/13/backups/pg_wal/%f'
archive_cleanup_command=''

edit and save the file.

Restart the postgresql13

	postgres$ sudo systemctl restart postgresql-13

	psql show archive_mode;
	show archive_timeout;
	show archive_command;
	show archive_cleanup_command;

dvdrental 99+# select name, setting, unit from pg_settings where name like 'archive%';

		name					|setting 																									|unit
		----------------		--------------------------------------------------------------------------------------------------------	------
		archive_cleanup_command
		archive command			archive_command | test ! -f /var/lib/pgsql/13/data/pg_wal/%f && cp %p /var/lib/pgsql/13/backups/pg_wal/%f
		archive_mode			 on
		archive_timeout			 300	<-- 5 mn																									 s
		
		
Post verification let''s forcefully switch the wasl logfiles;

	psql

	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();
	select pg_switch_wal();

	alter user postgres password 'password';

Initiate a compressed pg basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup

	pg_basebackup -h localhost -p 5432 -U postgres -D /var/lib/pgsql/pg_backup -Ft -z -Xs -P  <-- local backup

	-F, 	--format=p|t		output format (plain (default), tar)
	-z, 	gzip				compress tar output
	-X		--wal-method=none 	fetch stream

Initiate an uncompressed pg_basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup_uncompressed

Initiate an uncompressed pg_basebackup to a destination directory

	mkdir -p /var/lib/pgsql/pg_backup_uncompressed  (remove the -z option)

	pg_basebackup -h localhost -p 5432 -U postgres -D/var/lib/pgsql/pg_backup_uncompressed -Ft -Xs -P

Verify that the uncompressed backup has been taken


